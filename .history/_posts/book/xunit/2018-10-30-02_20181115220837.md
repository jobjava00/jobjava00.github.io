---
layout: archive
title: "[xUnit 테스트 패턴] 01장 - 02장 (테스트 냄새)"
date: 2018-10-29
excerpt: ""
tags: [book, xunit, xUnit 테스트 패턴, 테스트 냄새]
category: [book/xunit]
#read_time: true
#share: true

sidebar:
  nav: "book"
---

* * *

# 01장 - 간단하게 둘러보기

## 가장 확실하면서도 간단한 테스트 자동화 전략

* 5가지 테스트 자동화 전략
  * 개발 프로세스
    * 코드 개발에 사용되는 프로세스가 테스트에 미치는 영향
  * 고객 테스트
    * 궁극적인 정의로서 가장 먼저 작성해야 하는 테스트
  * 단위 테스트
    * 설계가 점진적으로 나타나게 해주고 전체 코드가 전부 테스트 될 수 있게 해주는 테스트
  * 테스트 구성
    * 테스트 메소드와 테스트케이스 클래스 구성하는 방법

### 개발 프로세스

* 어떤 상태를 성공이라고 할지에 대한 의견 일치를 볼 수 있다.
  * 소프트웨어를 개발하기 전에 고객이 테스트를 정의할 수 없다면 이미 문제가 있다.
* 테스트 주도 개발을 하면 소프트웨어를 테스트 가능하게 할 수 있다.
  * 코드를 작성하기 전에 먼저 단위 테스트를 작성하고 여기에서 소프트웨어 설계를 이끌어 낸다.

### 고객 테스트

* 고객이 시스템에 무엇을 기대하는지에 대한 핵심이 들어 있어야 한다.
* 고객테스트는 성공했을 때 어떻게 보여야 하는지를 정의 함.
* 개발 기간 동안 고객 테스트를 통해 실제 시스템이 어떻게 돌아가는지를 보여줄 수 있게 노력한다.

### 단위 테스트

* 모든 테스트가 클래스의 public 인터페이스로 왕복 테스트(Round-Trp Test)를 하는 완전 자동 테스트여야 한다.
* 각 테스트는 하나의 시나리오에 하나의 메소드 or 객체만 실행 되게 한다.
* 문서로서의 테스트로도 쓸 수 있게 한다.

### 테스트 하기 쉬운 설계

* 비즈니스 로직을 데이터베이스나 사용자 인터페이스와 분리 해야 함.

### 테스트 조직

* 테스트케이스 클래스에 테스트 메소드가 많아지면 메소드나 필요한 픽스처별로 클래스를 나눈다.
  * 기능별 테스트케이스 클래스
  * 픽스처별 테스트 케이스 클래스
    * 암묵적 설치 : 모든 픽스처 설치 코드를 setUp 메소드에 옮겨 놓는다.

* * *

# 02장 - 테스트 냄새

## 테스트 냄새

* 문제에 대한 증상
* 냄새는 여러 원인으로 발생할 수 있으므로 냄새만으로 무엇이 잘못됐는지 정확히 알 수 없음

### 테스트 냄새의 종류

* 코드 냄새
  * 테스트 코드를 읽고 쓸 때 발견 할 수 있는 코드 레벨의 안티 패턴
  * 행동을 취하기 전에 먼저 발견돼야 하고, 그 필요성은 사람마다 다르게 느낌
  * 스크립트 기반 테스트와 기록 테스트를 포함한 모든 종류의 테스트에 적용
* 동작 냄새
  * 결정적인 순간(빌드를 위한 코드 통합)에 테스트를 실패시키거나 컴파일 실패가 되기 때문에 필수적으로 해결해야 함.
  * 스크립트 기반 테스트와 기록 테스트 둘 다에 나타남
* 프로젝트 냄새
  * 프로젝트 매니저나 고객 등 테스트 코드와 상관없는 사람들이 맡게 됨.
  * 프로젝트가 전반적으로 얼마나 건강한지 알 수 있는 척도가 됨.

### 냄새가 날 때 대처 방안

* 테스트 자동화 전략을 선택하고 좋은 테스트 자동화 코드 표준을 지킬 때 많은 냄새를 피할 수 있다.
* 냄새가 발생한 근본 원인 발경하는 방법 '5 Whys'[TPS]
  * '왜?' 라는 질문을 5번 정도 하면 충분함
    * 왜 이런일이 발생했나?
      * 어떤 이유로 발생했나?

## 냄새 분류

### 프로젝트 냄새

* 프로젝트에서 뭔가가 잘못돼가고 있을 때 맡을 수 있는 현상
* 근본 원인
  * 하나 이상의 코드 냄새나 동작 냄새가 있다.
* 냄새를 맡을 수 있는 지표
  * 정규 테스트나 사용자/고객 테스트에서 발견되는 결함의 수로 측정
  * 제품 버그의 수가 예상보다 많다면 "어떻게 이렇게 많은 버그가 자동 테스트를 통과할 수 있었는지" 물어봐야 함
* 빌드가 너무 자주 실패하고, 깨진 빌드를 고치는 데 몇 분 이상 걸린다면 고민 해야 함.
  * 보통 원인은 소프트웨어의 버그 때문이 아닌 버그투성이 테스트 때문이다.
    * 테스트 버그를 고치느라 자원을 낭비하면서도 막상 제품 코드의 품질은 전혀 향상되지 않는 경우
* 버그 투성이 테스트
  * 높은 테스트 유지 비용 발생

### 동작 냄새

* 테스트를 컴파일하거나 실행할 때 맡을 수 있다.
* 깨지기 쉬운 테스트
  * 한 번 통과할 테스트가 여러 이유에서 실패 할 때 나타남
  * 근본 원인 4가지
    * 인터페이스에 민감함
    * 동작에 민감함
    * 데이터에 민감함
    * 문맥에 민감함
* 변덕스러운 테스트의 원인
  * 서로 반응하는 테스트
    * 여러 테스트가 공유 픽스처를 같이 사용하는 경우
    * 연쇄 실패를 일으킬 수 있다.
  * 테스트 실행 전쟁
    * 여러 테스트 실행기가 동시에  공유 픽스처를 갖고 테스트를 돌릴 때 발생
  * 반복 안 되는 테스트
    * 문제 발 생시 테스트 도릴 때 마다 직접 수동 조정 해줘야 함.
* 자동 단위 테스트에서는 실패가 발생 했을 때 원인을 분명하게 보여줘 디버거를 최대한 쓰지 않아도 되게 한다.
* 느린 테스트
  * 생산성을 저해하는 또 다른 냄새
  * 테스트 실행에 30초 이상이 걸리면 코드 수정시 마다 테스트 하지 않고 미루게 됨
  * 해결책 : 공유 픽스처
    * 여러 동작 냄새를 불러 일으킬 수 있어서 최후의 수단으로만 사용 해야 함.

### 코드 냄새

* 애매한 테스트
  * 테스트의 의도를 보여주지 않아 테스트 목적을 파악하기 어렵게 함.
  * 테스트 유지 보수 비용 증가
  * 버그투성이 테스트를 만들게 함.
* 테스트 내 조건문 로직
  * 테스트에 여러 실행 경로가 있다면 매번 어떤 경로로 실행될지 확실 할 수 없음
* 하드 코딩된 테스트 데이터
  * 테스트를 이해하기 어렵게 한다.
  * 데이터베이스를 쓰는 SUT를 테스트할 때 문제가 된다.
  * 변덕스러운 테스트, 깨지기 쉬운 테스트가 되기 쉽다.
* 테스트 코드 중복
  * 테스트 유지 보수 비용 증가
  * 애매한 테스트가 되기 쉽고 관리가 어렵다.
  * 공통 코드들은 테스트 유틸리티 메소드로 묶어내야 한다.
* 제품 코드 내 테스트 로직
  * 제품 코드 안에서 테스트 코드가 실행되지 않는 것을 보장 할 수 없음