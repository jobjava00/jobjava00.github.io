---
layout: archive
title: "[xUnit 테스트 패턴] 15장 - 코드 냄새"
date: 2018-11-27
excerpt: ""
tags: [book, xunit, xUnit 테스트 패턴, 코드 냄새]
category: [book/xunit]
#read_time: true
#share: true

sidebar:
  nav: "book"
---

* * *

# 15장 - 코드 냄새

## 애매한 테스트

### 증상 : 애매한 테스트

* 테스트를 한눈에 이해하기 어렵다.

### 미치는 영향 : 애매한 테스트
  
* 이해하기 어렵고 유지 보수하기도 어렵다.
* 문서로서의 테스트 만들기 업려고, 높은 테스트 유지 비용이 발생 할 수 있다.
* 버그 투성이 테스트, 욕심쟁이 테스트가 될 수 있다.

### 원인 : 애매한 테스트

* 테스트 메소드에 정보가 너무 많거나 적을 때 발생
* 욕심쟁이 테스트
  * 하나의 테스트 메소드에 너무 많은 기능을 검증하려는 테스트
* 미스터리한 손님
  * 픽스처와 검증 로직의 일부가 테스트 바깥에 있어 코드에서 이들 간의 인과 관계가 보이지 않는 테스트
* 장황한 테스트(Verbose Test)의 일반적인 문제점
  * 일반 픽스처 - 필요 이상으로 큰 픽스처 생성 or 참조
  * 관련 없는 정보
  * 하드 코딩된 테스트 데이터
  * 간접 테스트

#### 원인 : 욕심쟁이 테스트

* 하나의 테스트 메소드에서 너무 많은 기능을 검증하려는 테스트

##### 증상 : 욕심쟁이 테스트

* `없는 거 뺴고 전부 다 검증`
* 어디까지가 픽스처 설치, 어디서부터 SUT 실행인지 알기 어려움
  * SUT 실행 및 검증을 여러 단계에 거쳐서 함

##### 근본 원인 : 욕심쟁이 테스트

* 수동 테스트 시 테스트할 때마나 설치하는 고생을 줄이기 위해 별개의 테스트 조건들이라도 하나의 테스트 케이스에 전부 몰아넣어도 된다.

##### 해결책 : 욕심쟁이 테스트

* 자동화 된 테스트라면 결함 국소화를 위해 단일 조건 테스트 스위트로 만드는게 낫다.

#### 원인 : 미스터리한 손님

* 픽스처와 검증 로직의 일부가 테스트 바깥에 있어 코드에서 이들 간의 인과 관계가 보이지 않는 테스트

##### 증상 : 미스터리한 손님

* 픽스처 설치나 테스트의 결과 검증부가 테스트에서는 볼 수 없는 정보에 의존하고 검증하려는 동작을 이해하기 어렵다면 미스터리한 손님 문제가 있는 것
  * ex) 외부 파일(excel, csv 등) 로드에 의한 검증

##### 미치는 영향 : 미스터리한 손님

* 문서로서의 테스트 역할 할 수 없음
* 누군가가 외부 자원을 수정하거나 지울 수 있다.
  * 자원 낙관주의(Resource Optimism))
* 공유 픽스처라면 다른 테스트에서 픽스처 수정 시 변덕스러운 테스트가 될 수 있다.

##### 근본 원인 : 미스터리한 손님

* 외부 자원에 테스트가 의존
  * SUT 메소드에 전달되는 외부 파일 이름, 파일 내용이 SUT의 동작을 결정
  * 리터럴 키로 식별되는 데이터베이스 레코드의 내용을 읽어 객체에 쓴 뒤 이를 테스트에서 사용 or SUT에 전달
  * 파일에서 읽어 들인 내용을 단언 메소드 호출에 사용
  * 설치 데코레이터(Setup Decorator)로 공유 픽스처를 만들고 결과 검증 로직에서는 공유 픽스처의 객체들을 변수로 참조
  * 암묵적 설치(Implicit Setup)로 일반 픽스처를 설치하고 테스트 메소드에서 인스턴스 변수나 클래스 변수로 접근

##### 해결책 : 미스터리한 손님

* 인라인 설치로 신선한 픽스처를 쓰는 방법
  * 파일을 쓰는 경우
    * 파일 내용을 테스트에 문자열로 저장하고 그 내용을 파일에 다시 쓰거나 픽스처 설치 시 파일 시스템 테스트 스텝에 둘 수 있다.
  * 공유 픽스처나 암묵적 설치를 쓰는 경우
    * 픽스처 안의 객체들에 찾기 메소드로 접근
    * 파일을 써야 하면 파일 이름과 디렉토리로 어떤 데이터가 들어있는지 짐작할 수 있게 함

#### 원인 : 일반 픽스처

* 테스트에서 기능 검증에 필요 이상으로 큰 픽스처를 생성하거나 참조

##### 근본 원인 : 일반 픽스처

* 여러 테스트를 지원하기 위해 만든 픽스처를 쓰는 경우
* 다른 픽스처가 필요한 테스트에서 암묵적 설치나 공유 픽스처를 쓰는 경우
* 모든 테스트의 요구 사항을 맞춰야 하는 표준 픽스처를 쓰기 때문

##### 미치는 영향 : 일반 픽스처

* 문서로서의 테스트를 달성하기 어렵게 된다.
* 깨지기 쉬운 픽스터가 되기 쉽다.
* 느린 테스트가 될 수 있다.

##### 해결책 : 일반 픽스처

* 최소 픽스처를 써야 한다.
* 신선한 픽스처를 써야 한다.
* 공유 픽스처를 써야 한다면 테스트별로 가상의 데이터베이스 샌드박스를 만드는것을 고려

#### 원인 : 관련 없는 정보

* SUT의 동작에 영향을 미치는 것이 무엇인지 코드만 봐서는 알기 어렵다.

##### 증상 : 관련 없는 정보

* 객체에 전달되는 값 중 무엇이 기대 출력에 영향을 미치는지 알기 어렵다.
  * ex) 객체에 값을 여러개 설정해야 하고 참조 객체도 설정해야 하는 경우
* 테스트 선조건을 알 수 없게 돼 테스트가 무엇을 검증하려는지 알기 어렵다.

##### 근본 원인 : 관련 없는 정보

* 테스트에 리터럴 값이나 변수 같은 데이터가 너무 많이 들어 있는 경우
* 절차형 상태 검증을 써서 결과 검즈에 필요한 모든 코드를 포함 시키는 경우

##### 미치는 영향 : 관련 없는 정보

* 문서로서의 테스트 달성하기 어렵다.
* 높은 테스트 유지 비용 발생
* 버그투성이 테스트 생길 가능성 높다.

##### 해결책 : 관련 없는 정보

* 관련 있는 정보만 인자로 받는 인자를 받는 생성 메소드 호출
* 테스트에 중요하지 않은 값은 생성 메소드의 기본값 지정 or 더미 객체로 교체
* 맞춤 단언문 사용

#### 원인 : 하드 코딩된 테스트 데이터

* 픽스처, 단언문, SUT 인자값이 테스트 메소드에 하드 코딩돼 있어 입력과 기대 결과 값 사이의 인과 관계가 애매함.

##### 증상 : 하드 코딩된 테스트 데이터

* 어떤 값들이 SUT의 동작에 영향을 미치는지 알기 어렵다.
* 변덕스러운 테스트 같은 동작 냄새가 날 수 있다.
* 리터럴 값(literal value) 사용
